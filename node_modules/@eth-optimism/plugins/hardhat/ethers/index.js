"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const contracts_1 = require("@eth-optimism/contracts");
/* Imports: Internal */
require("./types/type-extensions");
const helpers_1 = require("./internal/helpers");
const provider_1 = require("../internal/provider");
/**
 * Generates an ethers contract from a definition pulled from the optimism
 * contracts package.
 * @param ethers Ethers instance.
 * @param name Name of the contract to generate
 * @param args Constructor arguments to the contract.
 * @returns Ethers contract object.
 */
const getContractFromDefinition = (ethers, signer, name, args = [], ovm) => {
    const contractDefinition = contracts_1.getContractDefinition(name, ovm);
    const contractFactory = new ethers.ContractFactory(contractDefinition.abi, contractDefinition.bytecode, signer);
    return contractFactory.deploy(...args);
};
config_1.extendEnvironment((hre) => {
    hre.l2provider = plugins_1.lazyObject(() => {
        return provider_1.makeL2Provider(hre);
    });
    hre.l2ethers = plugins_1.lazyObject(() => {
        const { createProviderProxy, } = require('./internal/provider-proxy');
        const { ethers } = require('ethers');
        const providerProxy = createProviderProxy(hre.l2provider);
        const contracts = {};
        (async () => {
            if (!process.env.__OVM_USE_EXPERIMENTAL_FEATURES__) {
                return;
            }
            await new Promise((resolve, reject) => {
                let ticks = 0;
                setTimeout(() => {
                    if (ticks >= 50) {
                        reject(new Error('Unable to load L2 ethers in time!'));
                    }
                    if (hre.ethers && hre.l2ethers) {
                        resolve(null);
                    }
                    else {
                        ticks++;
                    }
                }, 50);
            });
            const l1ethers = hre.ethers;
            const l2ethers = hre.l2ethers;
            const l1accounts = await l1ethers.getSigners();
            const l2accounts = await l2ethers.getSigners();
            contracts.L1CrossDomainMessenger = await getContractFromDefinition(l1ethers, l1accounts[l1accounts.length - 1], 'mockOVM_GenericCrossDomainMessenger', [], false);
            try {
                contracts.L2CrossDomainMessenger = await getContractFromDefinition(l2ethers, l2accounts[1], 'mockOVM_GenericCrossDomainMessenger', [], true);
            }
            catch (err) {
                console.log(err);
            }
        })();
        return Object.assign(Object.assign({}, ethers), { 
            // The provider wrapper should be removed once this is released
            // https://github.com/nomiclabs/hardhat/pull/608
            provider: providerProxy, getSigners: async () => helpers_1.getSigners(hre), 
            // We cast to any here as we hit a limitation of Function#bind and
            // overloads. See: https://github.com/microsoft/TypeScript/issues/28582
            getContractFactory: helpers_1.getContractFactory.bind(null, hre), getContractAt: helpers_1.getContractAt.bind(null, hre), waitForBridgeRelay: async (response) => {
                const receipt = await response.wait();
                const l1Messages = await contracts.L1CrossDomainMessenger.queryFilter(contracts.L1CrossDomainMessenger.filters.SentMessage(), receipt.blockNumber, receipt.blockNumber);
                for (const message of l1Messages) {
                    await contracts.L2CrossDomainMessenger.relayMessage(message.args._sender, message.args._target, message.args._message, message.args._gasLimit);
                }
                const l2Messages = await contracts.L2CrossDomainMessenger.queryFilter(contracts.L2CrossDomainMessenger.filters.SentMessage(), receipt.blockNumber, receipt.blockNumber);
                for (const message of l2Messages) {
                    await contracts.L1CrossDomainMessenger.relayMessage(message.args._sender, message.args._target, message.args._message, message.args._gasLimit);
                }
            }, contracts });
    });
});
//# sourceMappingURL=index.js.map